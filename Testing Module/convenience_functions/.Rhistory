myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# how many trades were succesful (to be functioned)
mah <- subset(myresult,myresult$action %in% c("buy","sell") )
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
# Plot each trade's indicators and price action (to be functioned)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(1, 1))
i <- 1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -1000
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 1000
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$SL[mytest$action =="buy"& mytest$id ==ident][!is.na(mytest$SL[mytest$action =="buy"& mytest$id ==ident])], col = "green")
abline(h = mytest$RL[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$RL[mytest$action =="sell"& mytest$id ==ident])], col = "red")
# abline(h = 40)
#
# plot(mytest$volume, type ="l")
# lines(mytest$EMA_volume, col ="red")
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
mytest <- myresult
print(i)
}
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
# Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Dynamic_SR_Lines(roll = 70,
n_sort = 10,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
# Close last position
if(myresult$action[nrow(myresult)] == "keep") {
myresult$action[nrow(myresult)] <- "sell"
myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# how many trades were succesful (to be functioned)
mah <- subset(myresult,myresult$action %in% c("buy","sell") )
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
# Plot each trade's indicators and price action (to be functioned)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(1, 1))
i <- 1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -1000
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 1000
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$SL[mytest$action =="buy"& mytest$id ==ident][!is.na(mytest$SL[mytest$action =="buy"& mytest$id ==ident])], col = "green")
abline(h = mytest$RL[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$RL[mytest$action =="sell"& mytest$id ==ident])], col = "red")
# abline(h = 40)
#
# plot(mytest$volume, type ="l")
# lines(mytest$EMA_volume, col ="red")
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
mytest <- myresult
print(i)
}
rm(list = ls())
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1", "10 Utils.R", sep = "/"))
setDTthreads(1)
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Choose pair
pair <- "ETHEUR"
# Path to save results0
data_path <- "/media/chris/DATA/Documents/Bot_Trading/Historical_data"
# Create pair directory
dir.create(paste(data_path, pair, sep ="/"), showWarnings = FALSE)
# Fix path
pair_data_results <- paste(data_path, pair, sep ="/")
# Loading Data for operations --------------------------------------------------
options(digits = 5)
# Csv file saved with historical trades
file <- paste0(paste(pair_data_results, pair, sep = "/"), ".csv")
# Read it
frame <- fread(file)
file
rm(list = ls())
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1", "10 Utils.R", sep = "/"))
setDTthreads(1)
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Choose pair
pair <- "XETHZEUR"
# Path to save results0
data_path <- "/media/chris/DATA/Documents/Bot_Trading/Historical_data"
# Create pair directory
dir.create(paste(data_path, pair, sep ="/"), showWarnings = FALSE)
# Fix path
pair_data_results <- paste(data_path, pair, sep ="/")
# Loading Data for operations --------------------------------------------------
options(digits = 5)
# Csv file saved with historical trades
file <- paste0(paste(pair_data_results, pair, sep = "/"), ".csv")
# Read it
frame <- fread(file)
# # Fix
frame[, Date_POSIXct := anytime(as.numeric(as.character(V3)))]
frame[, Time := strftime(Date_POSIXct, format = "%H:%M:%S")]
colnames(frame) <- c("price", "volume", "epoch_time", "buy_sell", "market_limit",
"miscellaneous", "last_id", "Date_POSIXct", "Time")
frame[, Date := as.Date(Date_POSIXct)]
frame[, Hour := substr(frame$Time, 1,5)]
frame[, miscellaneous := NULL]
frame1 <- unique(frame)
frame1 <- subset(frame1, frame1$Date >= "2019-01-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '1 hours') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
candles
# Plot asset and select how many intervals
par(mfrow=c(1,1))
plot_candlesticks(dta = candles, Ns = nrow(candles), asset = pair)
SR_lines(data = candles, roll = nrow(candles), n_sort = 10, pair = pair, Ns = nrow(candles))
abline(h = candles$close[nrow(candles)], lty = "dashed", col = "blue")
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
train_data
# Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Dynamic_SR_Lines(roll = 35,
n_sort = 10,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
# Close last position
if(myresult$action[nrow(myresult)] == "keep") {
myresult$action[nrow(myresult)] <- "sell"
myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# how many trades were succesful (to be functioned)
mah <- subset(myresult,myresult$action %in% c("buy","sell") )
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
# Plot each trade's indicators and price action (to be functioned)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(1, 1))
i <- 1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -1000
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 1000
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$SL[mytest$action =="buy"& mytest$id ==ident][!is.na(mytest$SL[mytest$action =="buy"& mytest$id ==ident])], col = "green")
abline(h = mytest$RL[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$RL[mytest$action =="sell"& mytest$id ==ident])], col = "red")
# abline(h = 40)
#
# plot(mytest$volume, type ="l")
# lines(mytest$EMA_volume, col ="red")
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
mytest <- myresult
print(i)
}
frame1 <- unique(frame)
frame1 <- subset(frame1, frame1$Date >= "2019-01-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '2 hours') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
par(mfrow=c(1,1))
plot_candlesticks(dta = candles, Ns = nrow(candles), asset = pair)
SR_lines(data = candles, roll = nrow(candles), n_sort = 10, pair = pair, Ns = nrow(candles))
abline(h = candles$close[nrow(candles)], lty = "dashed", col = "blue")
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
# Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Dynamic_SR_Lines(roll = 35,
n_sort = 10,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
# Close last position
if(myresult$action[nrow(myresult)] == "keep") {
myresult$action[nrow(myresult)] <- "sell"
myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# how many trades were succesful (to be functioned)
mah <- subset(myresult,myresult$action %in% c("buy","sell") )
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
# Plot each trade's indicators and price action (to be functioned)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(1, 1))
i <- 1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -1000
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 1000
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$SL[mytest$action =="buy"& mytest$id ==ident][!is.na(mytest$SL[mytest$action =="buy"& mytest$id ==ident])], col = "green")
abline(h = mytest$RL[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$RL[mytest$action =="sell"& mytest$id ==ident])], col = "red")
# abline(h = 40)
#
# plot(mytest$volume, type ="l")
# lines(mytest$EMA_volume, col ="red")
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
mytest <- myresult
print(i)
}
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
# Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Dynamic_SR_Lines(roll = 100,
n_sort = 10,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
# Close last position
if(myresult$action[nrow(myresult)] == "keep") {
myresult$action[nrow(myresult)] <- "sell"
myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# Plot each trade's indicators and price action (to be functioned)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(1, 1))
i <- 1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -1000
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 1000
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$SL[mytest$action =="buy"& mytest$id ==ident][!is.na(mytest$SL[mytest$action =="buy"& mytest$id ==ident])], col = "green")
abline(h = mytest$RL[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$RL[mytest$action =="sell"& mytest$id ==ident])], col = "red")
# abline(h = 40)
#
# plot(mytest$volume, type ="l")
# lines(mytest$EMA_volume, col ="red")
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
mytest <- myresult
print(i)
}
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
# Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Dynamic_SR_Lines(roll = 100,
n_sort = 3,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
# Close last position
if(myresult$action[nrow(myresult)] == "keep") {
myresult$action[nrow(myresult)] <- "sell"
myresult$Price[nrow(myresult)] <- myresult$close[nrow(myresult)] * myresult$Units[nrow(myresult)]
}
# Calculate profits
calculate_profits(myresult)
# how many trades were succesful (to be functioned)
mah <- subset(myresult,myresult$action %in% c("buy","sell") )
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
#                                stoploss_trail = 0.02,
#                                stoploss_ult = 1,
#                                times_vol = 1)
#
# myresult <- Volume_trading(EMA_volume = 20,
#                            takeprofit= 0.05,
#                            stoploss_trail = 0.005,
#                            stoploss_ult = 0.005,
#                            times_vol = 5,
#                            candle_action_long = "bullish")
st <- Sys.time()
#                                stoploss_trail = 0.02,
#                                stoploss_ult = 1,
#                                times_vol = 1)
#
# myresult <- Volume_trading(EMA_volume = 20,
#                            takeprofit= 0.05,
#                            stoploss_trail = 0.005,
#                            stoploss_ult = 0.005,
#                            times_vol = 5,
#                            candle_action_long = "bullish")
st <- Sys.time()
myresult <- Dynamic_SR_Lines(roll = 100,
n_sort = 3,
takeprofit = 0.1,
stoploss_trail = 0.05,
stoploss_ult = 0.02)
end <- Sys.time()
st - end
frame1 <- unique(frame)
frame1 <- subset(frame1, frame1$Date >= "2019-01-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '1 hours') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
candles
# Best cross EMA so far
# 40_110_200_0.03_0.05
# 675.91
# 102
# 2020-01-10	2020-06-19	40_110_200_0.03_0.05
# # Badget
initial_budget <- 500
# # select period of data
candles_recent <- candles
# # Plot if like
# plot_candlesticks(dta = candles_recent, Ns = nrow(candles_recent), asset = pair)
# plot_candlesticks(dta = candles_recent, Ns = 100, asset = pair)
#
# # N Training Data
train_n <- ceiling(nrow(candles_recent) / 8)
train_n
# # Plot if like
# plot_candlesticks(dta = candles_recent, Ns = nrow(candles_recent), asset = pair)
# plot_candlesticks(dta = candles_recent, Ns = 100, asset = pair)
#
# # N Training Data
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
train_data
#
# # Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
test_data
# testing parameters
roll <- data.frame(roll = seq(20, 50, 75, 100, 200, 300), flag = 1)
# testing parameters
roll <- data.frame(roll = seq(20, 50, 75, 100, 200, 300), flag = 1)
# testing parameters
roll <- data.frame(roll = c(20, 50, 75, 100, 200, 300), flag = 1)
roll
n_sort <- data.frame(n_sort = seq(5, 50, 5), flag = 1)
n_sort
takeprofit <- data.frame(takeprofit = c(0.03, 0.05, 0.1), flag = 1)
# testing parameters
roll <- data.frame(roll = c(20, 50, 75, 100, 200, 300), flag = 1)
n_sort <- data.frame(n_sort = seq(5, 50, 5), flag = 1)
takeprofit <- data.frame(takeprofit = c(0.03, 0.05, 0.1), flag = 1)
stoploss_trail <- data.frame(stoploss_trail = c(0.01, 0.02), flag = 1)
stoploss_ult <- data.frame(stoploss_ult = c(0.01, 0.02), flag = 1)
stoploss_ult
#
testing_params <- left_join(roll, n_sort) %>%
left_join(takeprofit)%>% left_join(stoploss_trail)%>% left_join(stoploss_ult)
testing_params$flag <- NULL
testing_params <- subset(testing_params, testing_params$roll > testing_params$n_sort)
testing_params <- as.data.table(testing_params)
testing_params
600/24
600*60
36000/24
600*60
36000/60
600/24
# testing parameters
roll <- data.frame(roll = c(20, 50, 75, 100, 200, 300), flag = 1)
n_sort <- data.frame(n_sort = seq(5, 50, 5), flag = 1)
n_sort
# testing parameters
roll <- data.frame(roll = c(20, 50, 75, 100, 200, 300), flag = 1)
n_sort <- data.frame(n_sort = c(5, 10, 30), flag = 1)
takeprofit <- data.frame(takeprofit = c(0.03, 0.05, 0.1), flag = 1)
stoploss_trail <- data.frame(stoploss_trail = c(0.01, 0.02), flag = 1)
stoploss_ult <- data.frame(stoploss_ult = c(0.01, 0.02), flag = 1)
#
testing_params <- left_join(roll, n_sort) %>%
left_join(takeprofit)%>% left_join(stoploss_trail)%>% left_join(stoploss_ult)
testing_params$flag <- NULL
testing_params <- subset(testing_params, testing_params$roll > testing_params$n_sort)
testing_params <- as.data.table(testing_params)
testing_params
200*60
12000/24
12000/60
200/24
source('/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Testing Module/01 API Connect.R', echo=TRUE)
