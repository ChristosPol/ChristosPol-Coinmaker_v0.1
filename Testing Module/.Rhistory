#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 1,
plot.it = T)
frame1 <- unique(frame)
# frame1 <- subset(frame1, frame1$Date >= "2019-12-01" & frame1$Date <= "2020-06-01")
frame1 <- subset(frame1, frame1$Date >= "2020-01-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '60 minutes') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
p1 <- ggplot(data= candles, aes(x=1:nrow(candles), y=close)) +
geom_line(alpha = 0.5);p1
frame1 <- unique(frame)
# frame1 <- subset(frame1, frame1$Date >= "2019-12-01" & frame1$Date <= "2020-06-01")
frame1 <- subset(frame1, frame1$Date >= "2019-06-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '60 minutes') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
p1 <- ggplot(data= candles, aes(x=1:nrow(candles), y=close)) +
geom_line(alpha = 0.5);p1
frame1 <- unique(frame)
# frame1 <- subset(frame1, frame1$Date >= "2019-12-01" & frame1$Date <= "2020-06-01")
frame1 <- subset(frame1, frame1$Date >= "2019-04-01")
# Select interval
frame1[, interval := strftime(ceiling_date(as.POSIXct(Date_POSIXct), '60 minutes') , format = '%H:%M:%S')]
# Create candle stick dataset
candles <- frame1[, .(high = max(price), low = min(price), open = first(price),
close = last(price), volume = sum(volume)),
by = .(Date, interval)]
dim(candles)
p1 <- ggplot(data= candles, aes(x=1:nrow(candles), y=close)) +
geom_line(alpha = 0.5);p1
# # Testing strategies ------------------------------------------------------------
paraller_exec <- FALSE
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 1,
plot.it = T)
# # Testing strategies ------------------------------------------------------------
paraller_exec <- FALSE
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 1,
plot.it = T)
# # Testing strategies ------------------------------------------------------------
paraller_exec <- FALSE
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 1,
plot.it = T)
dev.off()
# # Testing strategies ------------------------------------------------------------
paraller_exec <- FALSE
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 0.03,
plot.it = T)
# # Testing strategies ------------------------------------------------------------
paraller_exec <- FALSE
# Badget
initial_budget <- 500
# select period of data
candles_recent <- candles
#
# training data here is not the traditional training set, but more of a
# placeholder initial dataset to calculate the indicators
train_n <- ceiling(nrow(candles_recent) / 30)
train_data <- candles_recent[1:train_n, ]
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Splines_Tangent(spar = 0.95,
takeprofit = 0.015,
stoploss_trail = 1,
stoploss_ult = 1,
plot.it = F)
calculate_profits(myresult)
win_ratio(myresult)
Sys.sleep(10)
rm(list = ls())
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1", "10 Utils.R", sep = "/"))
# Load optimized parameters from location
params <- read.table("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Parameter optimization/Parameters/ETHEUR/best params.csv",
header = TRUE,
sep = ",", stringsAsFactors = FALSE)
params
# Set parameters
spar = params$spar[nrow(params)]
takeprofit = params$takeprofit[nrow(params)]
stoploss_trail = params$stoploss_trail[nrow(params)]
stoploss_ult = params$stoploss_ult[nrow(params)]
options(digits = 5)
interval <- 5
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Get private balance url
url <- "https://api.kraken.com/0/private/Balance"
# Choose pair
pair <- "ETHEUR"
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
rm(list = ls())
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1", "10 Utils.R", sep = "/"))
# Load optimized parameters from location
params <- read.table("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Parameter optimization/Parameters/ETHEUR/best params.csv",
header = TRUE,
sep = ",", stringsAsFactors = FALSE)
# Set parameters
spar = params$spar[nrow(params)]
takeprofit = params$takeprofit[nrow(params)]
stoploss_trail = params$stoploss_trail[nrow(params)]
stoploss_ult = params$stoploss_ult[nrow(params)]
options(digits = 5)
interval <- 1
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Get private balance url
url <- "https://api.kraken.com/0/private/Balance"
# Choose pair
pair <- "ETHEUR"
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# Remove last row as its the candle that still ongoing
df <- df[-nrow(df), ]
df
# as numeric
df$open <- as.numeric(df$open)
df$high <- as.numeric(df$high)
df$low <- as.numeric(df$low)
df$close <- as.numeric(df$close)
df$volume <- as.numeric(df$volume)
df$servertime <- 0
df$systemtime <- 0
servertime <- myfun("https://api.kraken.com/0/public/Time", API_Key, API_Sign)
df$servertime[nrow(df)] <- as.character(servertime$result$rfc1123)
df$systemtime[nrow(df)] <- as.character(Sys.time())
df
# 2. Add Indicators
df[, c("x",
"spline",
"deriv",
"sign_derivs",
"change_sign",
"exit_condition",
"action",
"Units",
"Price",
"tp",
"ult_sl",
"trail_sl",
"id") := list(NA,NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA) ]
df$action <- as.character(df$action)
df$x <- 1:nrow(df)
# Calculate spline - derivative
smoothingSpline = smooth.spline(df[, close] ~ as.numeric(rownames(df)), spar = spar)
df[, spline := predict(smoothingSpline)$y]
df[, deriv := predict(smoothingSpline, deriv = 1)$y]
# Sign of deriv - [-2 for desc, 2 for asc]
df[, sign_derivs := c(sign(deriv))]
df[, change_sign := c(0, diff(sign(deriv)))]
lastrow <- df[nrow(df), ]
file.exists("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Trading Module/Trading_Table/da.csv")
if(file.exists("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Trading Module/Trading_Table/da.csv")){
tmp <- read.table("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Trading Module/Trading_Table/da.csv",
header = FALSE,
sep = ",", stringsAsFactors = FALSE)
colnames(tmp) <- colnames(lastrow)
da <- rbind(tmp, lastrow)
} else {
da <- lastrow
}
da
# Exit condition for takeprofit  - Fixed
tp <- tail(da$close[da$action == "buy"][!is.na(da$close[da$action == "buy"])], 1) + takeprofit * tail(da$close[da$action == "buy"][!is.na(da$close[da$action == "buy"])], 1)
if (length(tp) == 0) {
tp <- 0
}
# Ultimate stop loss
ult_sl <- tail(da$close[da$action == "buy"][!is.na(da$close[da$action == "buy"])], 1) - stoploss_trail * tail(da$close[da$action == "buy"][!is.na(da$close[da$action == "buy"])], 1)
if (length(ult_sl) == 0) {
ult_sl <- 0
}
if(nrow(da) > 1 ){
# Trailing stop loss
# browser()
if (da$action[nrow(da)-1] %in% c("buy", "keep") & ( da$close[nrow(da)] > da$close[nrow(da)-1] )  ){
trail_sl <- da$close[nrow(da)] - stoploss_trail * da$close[nrow(da)]
if( trail_sl < tail(da$trail_sl[!is.na(da$trail_sl)], 1)){
trail_sl <- tail(da$trail_sl[!is.na(da$trail_sl)], 1)
}else {
trail_sl <- da$close[nrow(da)] - stoploss_trail * da$close[nrow(da)]
}
} else if (da$action[nrow(da)-1] %in% c("buy", "keep") & ( da$close[nrow(da)] <= da$close[nrow(da)-1] ) ){
trail_sl <- tail(da$trail_sl[!is.na(da$trail_sl)], 1)
} else {
trail_sl <-0
}
if(length(trail_sl) == 0 ){
trail_sl <- 0
}
# browser()
}else{
trail_sl <-0
}
if(length(trail_sl) == 0 ){
trail_sl <- 0
}
da$tp[nrow(da)] <- tp
da$ult_sl[nrow(da)] <- ult_sl
da$trail_sl[nrow(da)] <- trail_sl
da$exit_condition[nrow(da)] <- da$trail_sl[nrow(da)] > da$close[nrow(da)] | da$ult_sl[nrow(da)] > da$close[nrow(da)] | da$tp[nrow(da)] < da$close[nrow(da)]
nrow(da
nrow(da) > 1
nrow(da) > 1
rm(list = ls())
# screen -S Live_Trading R
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1", "10 Utils.R", sep = "/"))
# Load optimized parameters from location
params <- read.table("/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Parameter optimization/Parameters/ETHEUR/best params.csv",
header = TRUE,
sep = ",", stringsAsFactors = FALSE)
# Set parameters
spar = params$spar[nrow(params)]
takeprofit = params$takeprofit[nrow(params)]
stoploss_trail = params$stoploss_trail[nrow(params)]
stoploss_ult = params$stoploss_ult[nrow(params)]
options(digits = 5)
interval <- 5
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Get private balance url
url <- "https://api.kraken.com/0/private/Balance"
# Choose pair
pair <- "ETHEUR"
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result[[1]])
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
df$Date_POSIXct <- as.character(df$Date_POSIXct)
df
# Description ------------------------------------------------------------------
# Scheduler for trading at the end of each candle and not intra-candle
library(cronR)
# Path of live trading Rscript
path <- "/media/chris/DATA/Documents/Bot_Trading/Coinmaker_v0.1/Trading Module/Live_trading.R"
# Command
cmd <- cron_rscript(path)
# add frequency and intervals
cron_add(cmd, frequency = '*/5 * * * *', id = 'Live trading', description = 'Live trading', at = '00:05')
# Check all jobs
cron_ls()
# Check all jobs
cron_ls()
# Stop Job
# cron_clear(ask = FALSE)
cron_rm(id = "Live trading")
