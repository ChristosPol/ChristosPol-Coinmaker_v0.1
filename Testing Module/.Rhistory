} else if ( fut$action[nrow(fut) - 1] %in% c("sell", "no action") | (is.na(fut$action[nrow(fut) - 1])
& fut$crossover[nrow(fut)] == "faster_EMA_lower")) {
fut$action[nrow(fut)] <- "no action"
}
train_data <- fut
# print(i)
}
return(train_data)
}
# Ninja trader Volume reversal with RSI ----------------------------------------
Volume_Reversal_RSI_NJ <- function(stoploss, rsi_bound, rsi_period, periods_volume, times_EMA_Vol, EMA_periods) {
# Train and test datasets
train_data[, c("exit_value",
"exit_condition",
"EMA_volume",
"EMA",
"RSI",
"crossover_volume",
"candle_pattern",
"Long_singal",
"action",
"Units",
"Price",
"id") := list(0,NA, NA,NA,NA,NA, NA, 0, NA, NA, NA, NA) ]
test_data[, c("exit_value",
"exit_condition",
"EMA_volume",
"EMA",
"RSI",
"crossover_volume",
"candle_pattern",
"Long_singal",
"action",
"Units",
"Price",
"id") := list(0, NA,NA,NA,NA,NA, NA, 0, NA, NA, NA, NA) ]
# Going intro the loop for test data -----------------------------------------
for (i in 1:nrow(test_data)){
fut <- rbind(train_data, test_data[i, ])
# Technical indicators -----------------------------------------------------
fut$EMA_volume <- EMA(fut$volume, periods_volume)
fut$crossover_volume[nrow(fut)-1] <-  ifelse(fut$volume[nrow(fut)-1] >  fut$EMA_volume[nrow(fut)-1]*times_EMA_Vol, "Volume_Spike","No_Spike")
# fut$crossover_volume[nrow(fut)-1] <- ifelse(fut$volume[nrow(fut)-1] >  max(fut$volume[(nrow(fut)-periods_volume): (nrow(fut)-2)]), "Volume_Spike","No_Spike")
fut$RSI <- RSI(fut$close, n = rsi_period)
fut$candle_pattern[nrow(fut)] <-  (fut$low[nrow(fut)-2] <= fut$low[nrow(fut)-1]) & (fut$low[nrow(fut)-2] <= fut$low[nrow(fut)]) &
(fut$close[nrow(fut)-2] >= fut$close[nrow(fut)-1]) & (fut$close[nrow(fut)-2] >= fut$open[nrow(fut)-2]) &
(fut$close[nrow(fut)-2] - fut$open[nrow(fut)-2]) < (fut$high[nrow(fut)-2] - fut$low[nrow(fut)-2])
fut$Long_singal[nrow(fut)][fut$candle_pattern[nrow(fut)] == TRUE & fut$crossover[nrow(fut)-1] =="Volume_Spike"] <- TRUE
fut$EMA <- EMA(fut$close, n = EMA_periods)
# Exit condition for stop loss
exit_value <- (fut$close[nrow(fut)] - tail(fut$close[!is.na(fut$action) & fut$action %in% c("buy", "keep")], 1)) / tail(fut$close[!is.na(fut$action) &fut$action %in% c("buy", "keep")], 1)
if (length(exit_value) == 0) {
exit_value <- 0
}
fut$exit_value[nrow(fut)] <- exit_value
fut$exit_condition <-  fut$exit_value <= -stoploss
# Deciding upon action -----------------------------------------------------
# Buy condition
if ( (is.na(fut$action[nrow(fut) - 1]) |  fut$action[nrow(fut) - 1] %in% c("sell", "no action")) &
fut$Long_singal[nrow(fut)] == TRUE & fut$RSI[nrow(fut)] < rsi_bound) {
fut$action[nrow(fut)] <- "buy"
fut$Units[nrow(fut)] <- initial_budget / fut$close[nrow(fut)]
fut$Price[nrow(fut)] <- fut$Units[nrow(fut)] * fut$close[nrow(fut)]
fut$id[nrow(fut)] <- round(runif(1, 10000, 5000000))
# Sell condition
} else if (fut$action[nrow(fut) - 1] %in% c("keep", "buy") &
fut$exit_condition[nrow(fut)] == TRUE ) {
fut$action[nrow(fut)] <- "sell"
fut$Units[nrow(fut)] <- fut$Units[nrow(fut) -1]
fut$Price[nrow(fut)] <- fut$close[nrow(fut)]* fut$Units[nrow(fut)]
fut$id[nrow(fut)] <- fut$id[nrow(fut)-1]
initial_budget <- fut$Price[nrow(fut)]
# Keep condition
} else if ( fut$action[nrow(fut) - 1] %in% c("buy", "keep")   &
fut$exit_condition[nrow(fut)] == FALSE  ) {
fut$action[nrow(fut)] <- "keep"
fut$Units[nrow(fut)] <- fut$Units[nrow(fut) -1 ]
fut$id[nrow(fut)] <- fut$id[nrow(fut)-1]
} else {
fut$action[nrow(fut)] <- "no action"
}
train_data <- fut
# print(i)
}
return(train_data)
}
###
RSI_Period = 5
RSI_below = 40
EMA_volume = 20
takeprofit = 0.05
stoploss_trail = 0.05
stoploss_ult <- 0.1
times_vol = 1
Pure_RSI_Volume_Trailing <- function(RSI_Period, RSI_below, EMA_volume, takeprofit, stoploss_trail,stoploss_ult, times_vol) {
# Train and test datasets
train_data[, c("RSI",
"EMA_volume",
"exit_value",
"exit_condition",
"crossover_volume",
"crossover_RSI",
"action",
"Units",
"Price",
"tp",
"ult_sl",
"trail_sl",
"id") := list(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA) ]
test_data[, c("RSI",
"EMA_volume",
"exit_value",
"exit_condition",
"crossover_volume",
"crossover_RSI",
"action",
"Units",
"Price",
"tp",
"ult_sl",
"trail_sl",
"id") := list(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA) ]
# Going intro the loop for test data -----------------------------------------
for (i in 1:nrow(test_data)){
fut <- rbind(train_data, test_data[i, ])
# RSI and Volume
fut$RSI <- RSI(fut$close, n = RSI_Period)
fut$EMA_volume <- EMA(fut$volume, n = EMA_volume)
# Technical indicators -----------------------------------------------------
# Volume Crossing of volume over the SMA(volume, n_periods)
fut$crossover_volume[nrow(fut)] <- ifelse(fut$volume[nrow(fut)] > fut$EMA_volume[nrow(fut)] * times_vol ,
"volume_higher", "volume_lower")
# RSI Crossing of upper or lower bounds
fut$crossover_RSI[nrow(fut)] <- ifelse(fut$RSI[nrow(fut)] < RSI_below ,
"RSI_lower", "RSI_higher")
# Exit condition for takeprofit  - Fixed
tp <- (fut$close[nrow(fut)] - tail(fut$close[!is.na(fut$action) &fut$action =="buy"], 1)) / tail(fut$close[!is.na(fut$action) &fut$action =="buy"], 1)
if (length(tp) == 0) {
tp <- 0
}
# Trailing stop loss
# Exit condition for takeprofit  - Fixed
trail_sl <- (fut$close[nrow(fut)] - tail(fut$close[!is.na(fut$action) &fut$action %in% c("buy", "keep")], 1)) / tail(fut$close[!is.na(fut$action) &fut$action %in% c("buy", "keep")], 1)
if (length(trail_sl) == 0) {
trail_sl <- 0
}
# Ultimate stop loss
ult_sl <- (fut$close[nrow(fut)] - tail(fut$close[!is.na(fut$action) &fut$action %in% c("buy")], 1)) / tail(fut$close[!is.na(fut$action) &fut$action %in% c("buy")], 1)
if (length(ult_sl) == 0) {
ult_sl <- 0
}
fut$tp[nrow(fut)] <- tp
fut$ult_sl[nrow(fut)] <- ult_sl
fut$trail_sl[nrow(fut)] <- trail_sl
fut$exit_condition[nrow(fut)] <- fut$tp[nrow(fut)] > takeprofit | fut$ult_sl[nrow(fut)] <= -stoploss_trail | fut$trail_sl[nrow(fut)] <= -stoploss_ult
# Deciding upon action -----------------------------------------------------
# Buy condition
if ( (is.na(fut$action[nrow(fut) - 1]) |  fut$action[nrow(fut) - 1] %in% c("sell", "no action")) &
fut$crossover_volume[nrow(fut)] == "volume_higher" &  fut$crossover_RSI[nrow(fut)] == "RSI_lower" ) {
fut$action[nrow(fut)] <- "buy"
fut$Units[nrow(fut)] <- initial_budget / fut$close[nrow(fut)]
fut$Price[nrow(fut)] <- fut$Units[nrow(fut)] * fut$close[nrow(fut)]
fut$id[nrow(fut)] <- round(runif(1, 10000, 5000000))
# Sell condition
} else if (fut$action[nrow(fut) - 1] %in% c("keep", "buy") & (
fut$exit_condition[nrow(fut)] == TRUE  )) {
fut$action[nrow(fut)] <- "sell"
fut$Units[nrow(fut)] <- fut$Units[nrow(fut) -1]
fut$Price[nrow(fut)] <- fut$close[nrow(fut)]* fut$Units[nrow(fut)]
fut$id[nrow(fut)] <- fut$id[nrow(fut)-1]
initial_budget <- fut$Price[nrow(fut)]
# Keep condition
} else if ( fut$action[nrow(fut) - 1] %in% c("buy", "keep")   &
fut$exit_condition[nrow(fut)] == FALSE  ) {
fut$action[nrow(fut)] <- "keep"
fut$Units[nrow(fut)] <- fut$Units[nrow(fut) -1 ]
fut$id[nrow(fut)] <- fut$id[nrow(fut)-1]
} else {
fut$action[nrow(fut)] <- "no action"
}
train_data <- fut
# print(i)
}
return(train_data)
}
###
# Calculate profits and number of trades ---------------------------------------
calculate_profits <- function(dataset){
calcu <- dataset[action %in% c("buy", "sell"), ]
calcu <- subset(calcu,  !calcu$id %in% names(which(table(calcu$id) ==1)))
if (nrow(calcu) > 0) {
profit <- c()
profit_sum <- c()
ids <- unique(calcu$id)
for(i in 1:length(ids)){
profit[i] <-   calcu$Price[calcu$action =="sell" & calcu$id == ids[i]] - calcu$Price[calcu$action =="buy" & calcu$id == ids[i]]
}
profit_sum <- sum(profit)
dd <- data.frame(profit = profit_sum, n_trades = length(unique(calcu$id)),
enter_date = unique(calcu$Date)[1], exit_date = tail(unique(calcu$Date), 1))
} else {
dd <- data.frame(profit = 0, n_trades = 0, enter_date = as.Date("2020-04-07"), exit_date =as.Date("2020-04-07"))
}
write.table(dd, "/media/chris/DATA/Documents/Bot_Trading/Historical_data/myDF.csv",
sep = ",", row.names = FALSE, col.names = !file.exists("/media/chris/DATA/Documents/Bot_Trading/Historical_data/myDF.csv"), append = T)
return(dd)
}
# Private API calls ------------------------------------------------------------
myfun <- function (url, key, secret) {
# Nonce and post info
nonce <- as.character(as.numeric(Sys.time()) * 1000000)
post_data <- paste0("nonce=", nonce)
# Strip kraken url
method_path <- gsub("^.*?kraken.com", "", url)
# Secret APi key
sign <- hmac(key =  RCurl::base64Decode(secret, mode = "raw"),
object = c(charToRaw(method_path), digest(object = paste0(nonce, post_data),
algo = "sha256",
serialize = FALSE,
raw = TRUE)),
algo = "sha512", raw = TRUE)
# Header
httpheader <- c(`API-Key` = key, `API-Sign` =  RCurl::base64Encode(sign))
curl <- RCurl::getCurlHandle(useragent = paste("Rbitcoin", packageVersion("Rbitcoin")))
query_result_json <- rawToChar(RCurl::getURLContent(curl = curl,
url = url,
binary = TRUE,
postfields = post_data,
httpheader = httpheader))
query_result <- jsonlite::fromJSON(query_result_json)
return(query_result)
}
# Download OLHC data and calcualte indicators. Write last line and append each time
#-------------------------------------------------------------------------------
OHLC_action <- function(pair, interval){
repeat{
# 1. Get the OHLC - Repeat this call every x interval
what <- tryCatch(
{
url <- paste0('https://api.kraken.com/0/public/OHLC?pair=',pair,'&interval=', interval)
dat <- jsonlite::fromJSON(url)
},
error = function(e){})
if(is.null(dat$result[1])) next # error, skip
if(nrow(as.data.frame(dat$result[1])) == 0) break # last batch empty
df <- as.data.table(dat$result$XETHZEUR)
colnames(df) <- c("time", "open", "high", "low", "close",
"vwap", "volume", "count")
df[, Date_POSIXct := anytime(as.numeric(as.character(time)))]
# as numeric
df$open <- as.numeric(df$open)
df$high <- as.numeric(df$high)
df$low <- as.numeric(df$low)
df$close <- as.numeric(df$close)
# 2. Add Indicators
df[, c(paste0("EMA", "_", fast_EMA), paste0("EMA", "_", slow_EMA), "crossover", "action", "Units", "Price", "id") := list(NA, NA,0, NA, NA, NA, NA) ]
df[, c(paste0("EMA", "_", fast_EMA), paste0("EMA", "_", slow_EMA)) := list( EMA(close, n = fast_EMA), EMA(close, n = slow_EMA) ) ]
df$crossover[get(paste0("EMA", "_", fast_EMA), df) > get(paste0("EMA", "_", slow_EMA), df)] <- 1
print(tail(df, 1))
Sys.sleep(interval*60)
}
}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                   Trade Balance
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Inputs -----------------------------------------------------------------------
# aclass = asset class (optional):  currency (default, always currency)
# asset = base asset used to determine balance (default = ZUSD)
# Values -----------------------------------------------------------------------
# eb = equivalent balance (combined bbalancealance of all currencies)
# tb = trade balance (combined  of all equity currencies)
# m = margin amount of open positions
# n = unrealized net profit/loss of open positions
# c = cost basis of open positions
# v = current floating valuation of open positions
# e = equity = trade balance + unrealized net profit/loss
# mf = free margin = equity - initial margin (maximum margin available to open new positions)
# ml = margin level = (equity / initial margin) * 100
# url      <- "https://api.kraken.com/0/private/Balance"
get_balance <- function (url, key, secret) {
nonce <- as.character(as.numeric(Sys.time()) * 1000000)
post_data <- paste0("nonce=", nonce)
method_path <- gsub("^.*?kraken.com", "", url)
sign <- hmac(key =  RCurl::base64Decode(secret, mode = "raw"),
object = c(charToRaw(method_path), digest(object = paste0(nonce,
post_data), algo = "sha256", serialize = FALSE,
raw = TRUE)), algo = "sha512", raw = TRUE)
httpheader <- c(`API-Key` = key, `API-Sign` =  RCurl::base64Encode(sign))
curl <- RCurl::getCurlHandle(useragent = paste("Rbitcoin", packageVersion("Rbitcoin")))
query_result_json <- rawToChar(RCurl::getURLContent(curl = curl,
url = url, binary = TRUE, postfields = post_data,
httpheader = httpheader))
query_result <- jsonlite::fromJSON(query_result_json)
return(query_result)
}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                   Add standard order
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# Inputs -----------------------------------------------------------------------
# pair = asset pair
# type = type of order (buy/sell)
# ordertype = order type:
#   market
# limit (price = limit price)
# stop-loss (price = stop loss price)
# take-profit (price = take profit price)
# stop-loss-profit (price = stop loss price, price2 = take profit price)
# stop-loss-profit-limit (price = stop loss price, price2 = take profit price)
# stop-loss-limit (price = stop loss trigger price, price2 = triggered limit price)
# take-profit-limit (price = take profit trigger price, price2 = triggered limit price)
# trailing-stop (price = trailing stop offset)
# trailing-stop-limit (price = trailing stop offset, price2 = triggered limit offset)
# stop-loss-and-limit (price = stop loss price, price2 = limit price)
# settle-position
# price = price (optional.  dependent upon ordertype)
# price2 = secondary price (optional.  dependent upon ordertype)
# volume = order volume in lots
# leverage = amount of leverage desired (optional.  default = none)
# oflags = comma delimited list of order flags (optional):
#   viqc = volume in quote currency (not available for leveraged orders)
# fcib = prefer fee in base currency
# fciq = prefer fee in quote currency
# nompp = no market price protection
# post = post only order (available when ordertype = limit)
# starttm = scheduled start time (optional):
#   0 = now (default)
# +<n> = schedule start time <n> seconds from now
# <n> = unix timestamp of start time
# expiretm = expiration time (optional):
#   0 = no expiration (default)
# +<n> = expire <n> seconds from now
# <n> = unix timestamp of expiration time
# userref = user reference id.  32-bit signed number.  (optional)
# validate = validate inputs only.  do not submit order (optional)
# optional closing order to add to system when order gets filled:
#   close[ordertype] = order type
# close[price] = price
# close[price2] = secondary price
# Values -----------------------------------------------------------------------
# descr = order description info
# order = order description
# close = conditional close order description (if conditional close set)
# txid = array of transaction ids for order (if order was added successfully)
# url      <- "https://api.kraken.com/0/private/AddOrder"
# type <- "sell"
# ordertype <- "market"
# volume <- 0.1
add_market_order <- function(url, key, secret, pair, type, ordertype, volume) {
nonce <- as.character(as.numeric(Sys.time()) * 1000000)
post_data <- paste0("nonce=", nonce, "&pair=", pair, "&type=", type, "&ordertype=", ordertype,
"&volume=", volume)
method_path <- gsub("^.*?kraken.com", "", url)
sign <- hmac(key =  RCurl::base64Decode(secret, mode = "raw"),
object = c(charToRaw(method_path), digest(object = paste0(nonce,
post_data), algo = "sha256", serialize = FALSE,
raw = TRUE)), algo = "sha512", raw = TRUE)
httpheader <- c(`API-Key` = key, `API-Sign` =  RCurl::base64Encode(sign))
curl <- RCurl::getCurlHandle(useragent = paste("Rbitcoin", packageVersion("Rbitcoin")))
query_result_json <- rawToChar(RCurl::getURLContent(curl = curl,
url = url, binary = TRUE, postfields = post_data,
httpheader = httpheader))
query_result <- jsonlite::fromJSON(query_result_json)
return(query_result)
}
# # Testing strategies ------------------------------------------------------------
#
# # Badget
initial_budget <- 500
# # select period of data
candles_recent <- candles
#
# # Plot if like
# plot_candlesticks(dta = candles_recent, Ns = nrow(candles_recent), asset = pair)
# plot_candlesticks(dta = candles_recent, Ns = 100, asset = pair)
#
# # N Training Data
train_n <- ceiling(nrow(candles_recent) / 40)
train_data <- candles_recent[1:train_n, ]
#
# # Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
# Calculate profits
calculate_profits(myresult)
myresult <- Pure_RSI_Volume_Trailing(RSI_Period = 5,
RSI_below = 40,
EMA_volume = 20,
takeprofit = 0.05,
stoploss_trail = 0.03,
stoploss_ult = 0.07,
times_vol = 1)
# Calculate profits
calculate_profits(myresult)
mah <- subset(myresult,myresult$action %in% c("buy", "sell") )
mah
mah <- mah[-nrow(mah),]
profitable_trades <- list()
ids_s <- unique(mah$id)
for(i in 1:length(unique(mah$id))){
profitable_trades[[i]] <- mah$close[mah$id == ids_s[i] & mah$action =="sell"]-mah$close[mah$id == ids_s[i] & mah$action =="buy"]
}
table(unlist(profitable_trades) > 0)
mytest <- myresult
idents <- unique(mytest$id)[!is.na(unique(mytest$id))]
par(mfrow = c(3, 1))
i <-1
for (i in 1:length(idents)){
h <- head(which(mytest$id == idents[i]),1) -50
if(h < 0){
h <- 1
}
t <- tail(which(mytest$id == idents[i]),1) + 50
mytest <- myresult[h:t, ]
ident <- idents[i]
plot(1:nrow(mytest), mytest$close, type = "l")
# lines(mytest$EMA_Trend_200, col = "red")
buyprice <- mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])]
sellprice <- mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])]
mtext(round((sellprice - buyprice)/buyprice, digits = 3), side = 3)
# plot_candlesticks(dta = mytest, Ns = nrow(mytest), a  sset = pair)
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="green")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$close[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="red")
abline(h = mytest$close[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="buy" & mytest$id ==ident])], col ="green")
abline(h = mytest$close[mytest$action =="sell" & mytest$id ==ident][!is.na(mytest$close[mytest$action =="sell" & mytest$id ==ident])], col ="red")
# plot(mytest$EMA, col ="red", type ="l")#, ylim = c(mn, mx))
# lines(mytest$EMA, col ="blue")#, ylim = c(mn, mx))
plot(mytest$volume, type ="l")
lines(mytest$EMA_volume, col ="grey")
points(which(mytest$action =="buy" & mytest$id ==ident), mytest$volume[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$volume[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
points(which(mytest$action =="sell"& mytest$id ==ident), mytest$volume[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$volume[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
# lines(mytest$EMA_130, col ="blue")
# plot(mytest$macd, type ="l")
# lines(mytest$signal, col ="red")
# abline(h = 0)
# abline(h = 40)
# points(which(mytest$action =="buy" & mytest$id ==ident), mytest$macd[mytest$action =="buy" & mytest$id ==ident][!is.na(mytest$macd[mytest$action =="buy" & mytest$id ==ident])], pch =19, col ="blue")
# points(which(mytest$action =="sell"& mytest$id ==ident), mytest$macd[mytest$action =="sell"& mytest$id ==ident][!is.na(mytest$macd[mytest$action =="sell"& mytest$id ==ident])], pch =19, col ="black")
#
# lines(mytest$Volume_SMA_5)
# abline(v = which(mytest$action =="buy" & mytest$id ==ident))
plot(mytest$RSI, type ="l")
abline(h = 30)
# abline(h = 85)
mytest <- myresult
print(i)
}
# # Testing strategies ------------------------------------------------------------
#
# # Badget
initial_budget <- 500
# # select period of data
candles_recent <- candles
#
# # Plot if like
# plot_candlesticks(dta = candles_recent, Ns = nrow(candles_recent), asset = pair)
# plot_candlesticks(dta = candles_recent, Ns = 100, asset = pair)
#
# # N Training Data
train_n <- ceiling(nrow(candles_recent) / 40)
train_data <- candles_recent[1:train_n, ]
#
# # Test, same
test_data <- candles_recent[(train_n + 1):nrow(candles_recent), ]
myresult <- Pure_RSI_Volume_Trailing(RSI_Period = 5,
RSI_below = 40,
EMA_volume = 20,
takeprofit = 0.05,
stoploss_trail = 0.03,
stoploss_ult = 0.07,
times_vol = 2)
# Calculate profits
calculate_profits(myresult)
myresult <- Pure_RSI_Volume_Trailing(RSI_Period = 5,
RSI_below = 30,
EMA_volume = 20,
takeprofit = 0.05,
stoploss_trail = 0.03,
stoploss_ult = 0.07,
times_vol = 1)
# screen -S pull_rest_eth_data R
.rs.restartR()
rm(list = ls())
setDTthreads(1)
options(digits=20)
options(scipen=999)
gc()
source(paste("/media/chris/DATA/Documents/Bot_Trading/Coinmaker", "10 Utils.R", sep = "/"))
# Pulling historical data ------------------------------------------------------
# API info
api_info <- read.table(paste("/media/chris/DATA/Documents/Bot_Trading", "API_Keys.txt", sep = "/"), sep = ";", header = T)
API_Key <- as.character(api_info$API_Key)
API_Sign <- as.character(api_info$API_Sign)
# Choose pair
pair <- "XETHZEUR"
# Path to save results
data_path <- "/media/chris/DATA/Documents/Bot_Trading/Historical_data"
# Create pair directory
dir.create(paste(data_path, pair, sep ="/"), showWarnings = FALSE)
# Fix path
pair_data_results <- paste(data_path, pair, sep ="/")
# Loading Data for operations --------------------------------------------------
options(digits = 5)
# Csv file saved with historical trades
file <- paste0(paste(pair_data_results, pair, sep = "/"), ".csv")
# Read it
frame <- fread(file)
# # Fix
frame[, Date_POSIXct := anytime(as.numeric(as.character(V3)))]
# Choose initial ID for the first pull
options("width"=60)
v <- nanotime(Sys.time() - as.difftime(60, unit = "days"))
initial_id <- as.integer64( v )
initial_id <- as.integer64(v)
